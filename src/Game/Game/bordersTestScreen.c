#include "bordersTestScreen.h"

#include <stdbool.h>

#include "../Graphics/graphics.h"
#include "../Graphics/images.h"
#include "../Graphics/spineGfx.h"
#include "../Graphics/camera.h"
#include "../Graphics/debugRendering.h"
#include "../Graphics/imageSheets.h"
#include "../System/platformLog.h"
#include "../Utils/stretchyBuffer.h"
#include "../Input/input.h"

// Have wanted this multiple times for LD but always decided it would take too long to implement.
//  So here's an example to work from in the future.

static int* sbTiles = NULL;

#define MAP_WIDTH 32
#define MAP_HEIGHT 32

static bool blockingMap[MAP_WIDTH * MAP_HEIGHT];
static int spriteMap[MAP_WIDTH * MAP_HEIGHT];

// assuming row major
#define MAP_COORD_TO_IDX( x, y ) ( (x) + ( (y) * MAP_WIDTH ) )

#define SPRITE_WIDTH 32.0f
#define SPRITE_HEIGHT 32.0f

//***********************************************
//   Border sprite calculation
// Make it so borders in maps look nice, right now the way it works
// will only behave properly if you have only two states for a tile
// but it should be possible to expand this to be able to handle
// multiple types.

const static int NEIGHBOR_RIGHT = 1 << 0;
const static int NEIGHBOR_LEFT = 1 << 1;
const static int NEIGHBOR_UP = 1 << 2;
const static int NEIGHBOR_DOWN = 1 << 3;
const static int NEIGHBOR_DOWN_RIGHT = 1 << 4;
const static int NEIGHBOR_DOWN_LEFT = 1 << 5;
const static int NEIGHBOR_UP_RIGHT = 1 << 6;
const static int NEIGHBOR_UP_LEFT = 1 << 7;

static int cullNeighborFlags( int flags )
{
	// only care about diagonals if the the two other spots adjacent to it are not empty
		/*
			 011     011
			 0x1 and 0x1 are equivilant since the block in the lower right of the second one wouldn't effect how it should be drawn.
			 000     001
		*/
		// we'll just set stuff we don't care about to 0
	if( ( flags & ( NEIGHBOR_RIGHT | NEIGHBOR_UP ) ) != ( NEIGHBOR_RIGHT | NEIGHBOR_UP ) ) {
		flags &= ~NEIGHBOR_UP_RIGHT;
	}
	if( ( flags & ( NEIGHBOR_LEFT | NEIGHBOR_UP ) ) != ( NEIGHBOR_LEFT | NEIGHBOR_UP ) ) {
		flags &= ~NEIGHBOR_UP_LEFT;
	}
	if( ( flags & ( NEIGHBOR_RIGHT | NEIGHBOR_DOWN ) ) != ( NEIGHBOR_RIGHT | NEIGHBOR_DOWN ) ) {
		flags &= ~NEIGHBOR_DOWN_RIGHT;
	}
	if( ( flags & ( NEIGHBOR_LEFT | NEIGHBOR_DOWN ) ) != ( NEIGHBOR_LEFT | NEIGHBOR_DOWN ) ) {
		flags &= ~NEIGHBOR_DOWN_LEFT;
	}

	return flags;
}

static int levelSpriteIdxFromNeighborFlags( int flags )
{
	// first cull the unnecssary data
	flags = cullNeighborFlags( flags );

	// just a simple look up table, these values are generated by ORing together
	//  the NEIGHBOR_ numbers to match how the sprite sheet is layed out
	/*
	Where the number generated by the flags is at top, 1 represents a filled spot, and 0 and empty spot
	0    1    2    3    4    5    6    7
	000  000  000  000  010  010  010  010
	0x0  0x1  1x0  1x1  0x0  0x1  1x0  1x1
	000  000  000  000  000  000  000  000

	8    9    10   11   12   13   14   15
	000  000  000  000  010  010  010  010
	0x0  0x1  1x0  1x1  0x0  0x1  1x0  1x1
	010  010  010  010  010  010  010  010

	25   27   29   31   42   43   46   47
	000  000  010  010  000  000  010  010
	0x1  1x1  0x1  1x1  1x0  1x1  1x0  1x1
	011  011  011  011  110  110  110  110

	59   63   69   71   77   79   93   95
	000  010  011  011  011  011  011  011
	1x1  1x1  0x1  1x1  0x1  1x1  0x1  1x1
	111  111  000  000  010  010  011  011

	111  127  134  135  142  143  159  174
	011  011  110  110  110  110  110  110
	1x1  1x1  1x0  1x1  1x0  1x1  1x1  1x0
	110  111  000  000  010  010  011  110

	175  191  199  207  223  239  255
	110  110  111  111  111  111  111
	1x1  1x1  1x1  1x1  1x1  1x1  1x1
	110  111  000  010  011  110  111
	*/
	switch( flags ) {
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
	case 11:
	case 12:
	case 13:
	case 14:
	case 15:
		return flags;
		break;
	case 25:
		return 16;
		break;
	case 27:
		return 17;
		break;
	case 29:
		return 18;
		break;
	case 31:
		return 19;
		break;
	case 42:
		return 20;
		break;
	case 43:
		return 21;
		break;
	case 46:
		return 22;
		break;
	case 47:
		return 23;
		break;
	case 59:
		return 24;
		break;
	case 63:
		return 25;
		break;
	case 69:
		return 26;
		break;
	case 71:
		return 27;
		break;
	case 77:
		return 28;
		break;
	case 79:
		return 29;
		break;
	case 93:
		return 30;
		break;
	case 95:
		return 31;
		break;
	case 111:
		return 32;
		break;
	case 127:
		return 33;
		break;
	case 134:
		return 34;
		break;
	case 135:
		return 35;
		break;
	case 142:
		return 36;
		break;
	case 143:
		return 37;
		break;
	case 159:
		return 38;
		break;
	case 174:
		return 39;
		break;
	case 175:
		return 40;
		break;
	case 191:
		return 41;
		break;
	case 199:
		return 42;
		break;
	case 207:
		return 43;
		break;
	case 223:
		return 44;
		break;
	case 239:
		return 45;
		break;
	case 255:
		return 46;
		break;
	default:
		llog( LOG_ERROR, "Invalid neighbor flags passed in." );
		break;
	}

	return -1;
}


static bool isTileBlocked( int x, int y )
{
	if( ( x < 0 ) || ( x >= MAP_WIDTH ) || ( y < 0 ) || ( y >= MAP_HEIGHT ) ) {
		return true;
	}

	return blockingMap[MAP_COORD_TO_IDX( x, y )];
}

//***********************************************

static void calculateSprite( int x, int y )
{
	if( ( x < 0 ) || ( x >= MAP_WIDTH ) || ( y < 0 ) || ( y >= MAP_HEIGHT ) ) {
		return;
	}

	int i = MAP_COORD_TO_IDX( x, y );
	if( blockingMap[i] ) {
		// is blocked so we calculate the correct index
		// check four adjacent walls to see what type it is
		int wallTypeIdx = 0;

		if( isTileBlocked( x, y - 1 ) )		wallTypeIdx |= NEIGHBOR_UP;
		if( isTileBlocked( x, y + 1 ) )		wallTypeIdx |= NEIGHBOR_DOWN;
		if( isTileBlocked( x - 1, y ) )		wallTypeIdx |= NEIGHBOR_LEFT;
		if( isTileBlocked( x + 1, y ) )		wallTypeIdx |= NEIGHBOR_RIGHT;
		if( isTileBlocked( x - 1, y - 1 ) )	wallTypeIdx |= NEIGHBOR_UP_LEFT;
		if( isTileBlocked( x + 1, y - 1 ) ) wallTypeIdx |= NEIGHBOR_UP_RIGHT;
		if( isTileBlocked( x - 1, y + 1 ) ) wallTypeIdx |= NEIGHBOR_DOWN_LEFT;
		if( isTileBlocked( x + 1, y + 1 ) ) wallTypeIdx |= NEIGHBOR_DOWN_RIGHT;

		spriteMap[i] = sbTiles[levelSpriteIdxFromNeighborFlags( wallTypeIdx )];

	} else {
		// not blocked, just use the last sprite
		spriteMap[i] = sbTiles[47];
	}
}

static void setTileBlocked( int x, int y, bool blocked )
{
	if( ( x < 0 ) || ( x >= MAP_WIDTH ) || ( y < 0 ) || ( y >= MAP_HEIGHT ) ) {
		return;
	}
	int i = MAP_COORD_TO_IDX( x, y );

	blockingMap[i] = blocked;

	calculateSprite( x, y );

	calculateSprite( x + 1, y );
	calculateSprite( x - 1, y );
	calculateSprite( x, y + 1 );
	calculateSprite( x, y - 1 );

	calculateSprite( x + 1, y + 1 );
	calculateSprite( x + 1, y - 1 );
	calculateSprite( x - 1, y + 1 );
	calculateSprite( x - 1, y - 1 );
}

static Vector2 highlightPos;
static Vector2 prevMousePos;

typedef enum {
	MS_IDLE,
	MS_TURN_ON,
	MS_TURN_OFF,
	MS_MOVE
} MouseState;

static MouseState currState = MS_IDLE;
static int highlightImg;
static float zoomDelta;

static void startTurnOn( void )
{
	currState = MS_TURN_ON;
}

static void endTurnOn( void )
{
	currState = MS_IDLE;
}

static void startTurnOff( void )
{
	currState = MS_TURN_OFF;
}

static void endTurnOff( void )
{
	currState = MS_IDLE;
}

static void startMove( void )
{
	currState = MS_MOVE;
	input_GetMousePosition( &prevMousePos );
}

static void endMove( void )
{
	currState = MS_IDLE;
}

static int bordersTestScreen_Enter( void )
{
	cam_TurnOnFlags( 0, 1 );
	cam_SetCenteredProjectionMatrix( 0, 800, 600 );

	Vector2 mapCenter;
	mapCenter.x = ( MAP_WIDTH * SPRITE_WIDTH ) / 2.0f;
	mapCenter.y = ( MAP_HEIGHT * SPRITE_HEIGHT ) / 2.0f;
	cam_SetState( 0, mapCenter, 1.0f );
	
	gfx_SetClearColor( CLR_BLACK );

	img_LoadSpriteSheet( "Images/borders_template.ss", ST_DEFAULT, &sbTiles );
	highlightImg = img_Load( "Images/highlight.png", ST_DEFAULT );

	// set the map to empty
	for( int i = 0; i < ( MAP_WIDTH * MAP_HEIGHT ); ++i ) {
		blockingMap[i] = false;
		spriteMap[i] = sbTiles[47];
	}

	input_BindOnMouseButtonPress( SDL_BUTTON_LEFT, startTurnOn );
	input_BindOnMouseButtonRelease( SDL_BUTTON_LEFT, endTurnOn );

	input_BindOnMouseButtonPress( SDL_BUTTON_RIGHT, startTurnOff );
	input_BindOnMouseButtonRelease( SDL_BUTTON_RIGHT, endTurnOff );

	input_BindOnMouseButtonPress( SDL_BUTTON_MIDDLE, startMove );
	input_BindOnMouseButtonRelease( SDL_BUTTON_MIDDLE, endMove );

	return 1;
}

static int bordersTestScreen_Exit( void )
{
	return 1;
}

static void bordersTestScreen_ProcessEvents( SDL_Event* e )
{
	if( e->type == SDL_MOUSEWHEEL ) {
		zoomDelta = e->wheel.y * 0.1f;
	}
}

static void bordersTestScreen_Process( void )
{
	Vector2 mousePos;
	Vector2 inWorldMousePos;
	input_GetMousePosition( &mousePos );
	cam_ScreenPosToWorldPos( 0, &mousePos, &inWorldMousePos );

	int mapX = (int)floorf( ( inWorldMousePos.x + ( SPRITE_WIDTH / 2.0f ) ) / SPRITE_WIDTH );
	int mapY = (int)floorf( ( inWorldMousePos.y + ( SPRITE_HEIGHT / 2.0f ) ) / SPRITE_HEIGHT );

	switch( currState ) {
		case MS_TURN_ON:
			setTileBlocked( mapX, mapY, true );
			break;
		case MS_TURN_OFF:
			setTileBlocked( mapX, mapY, false );
			break;
	}

	highlightPos.x = mapX * SPRITE_WIDTH;
	highlightPos.y = mapY * SPRITE_HEIGHT;
}

static void bordersTestScreen_Draw( void )
{
	for( int y = 0; y < MAP_HEIGHT; ++y ) {
		for( int x = 0; x < MAP_WIDTH; ++x ) {
			int i = MAP_COORD_TO_IDX( x, y );
			Vector2 pos = vec2( x * SPRITE_WIDTH, y * SPRITE_HEIGHT );
			img_CreateDraw( spriteMap[i], 1, pos, pos, 0 );
		}
	}

	img_CreateDraw( highlightImg, 1, highlightPos, highlightPos, 1 );
}

static void bordersTestScreen_PhysicsTick( float dt )
{
	Vector2 delta = VEC2_ZERO;
	if( currState == MS_MOVE ) {
		Vector2 mousePos;
		input_GetMousePosition( &mousePos );
		vec2_Subtract( &prevMousePos, &mousePos, &delta );
		prevMousePos = mousePos;
	}
	cam_MoveNextState( 0, delta, zoomDelta );
	zoomDelta = 0.0f;
}

GameState bordersTestScreenState = { bordersTestScreen_Enter, bordersTestScreen_Exit, bordersTestScreen_ProcessEvents,
	bordersTestScreen_Process, bordersTestScreen_Draw, bordersTestScreen_PhysicsTick };